# Lazy Platform
Team Italy CTF 2022
Challenge Author: @mattiabrandon

## Description

```
I'm too lazy to implement the decryption of the ciphertexts, so I'll just give you what you need and you'll do the rest.

This is a remote challenge, you can connect to the service with:

nc lazy-platform.challs.teamitaly.eu 15004

Author: @mattiabrandon
```

## Challenge Explanation

For this challenge, we are given a netcat connection and the source code that is running on the server. Upon connecting to the NC port, we get the following: 

```
Welcome to Lazy platform! If you want to decrypt some messages, you can't do that here, you'll have to do it on your own
Choose one of the following options
[1] Encrypt
[2] Decrypt
[3] Get encrypted flag
[4] Exit
> 
```

Looks like we can give the system a piece of plaintext to encrypt. When we do so, we get the plaintext back, plus a key and an IV:

```
> 1
Enter a message to encrypt: test
Ciphertext: 48d8e329e3cacd3cb4f802e329def688
Key: f5ae881f552f64378d143003ff32b8d2f18798d2b38280d8163f53b1cc6a7225
IV: 54eb6c9f62f1cf67b86c5aa74e492732
```

We can also ask for the flag. However, when we do, we get back only the ciphertext with no key or IV:

```
> 3
Ciphertext: 9e3b24e1543f2dc49e7caa99ecfa49ca
```

And it looks like decryption isn't implemented at all:

```
> 2
I can't do that at the moment, I'm cooking a pizza
```

So it seems that we'll have to grab the flag ciphertext and decrypt it on our own. If only we had the key and the IV...

## The Vulnerability

Let's take a look at the source code for the `encrypt` option. We can see that they're using AES in CBC mode. 

```python
message = input("Enter a message to encrypt: ")
key = getrandbytes(32)
iv = getrandbytes(16)
ciphertext = AES.new(key, AES.MODE_CBC, iv).encrypt(
    pad(message.encode(), AES.block_size))
```

Same goes for the `get encrypted flag` option. The use of AES itself looks fine. 

```python
key = getrandbytes(32)
iv = getrandbytes(16)
ciphertext = AES.new(key, AES.MODE_CBC, iv).encrypt(
    pad(FLAG, AES.block_size))
print("Ciphertext:", ciphertext.hex())
```


However, what about that `getrandbytes` function? Turns out it's also defined in the source:

```python
def getrandbytes(n: int) -> bytes:
    return random.getrandbits(n * 8).to_bytes(n, "little")
```

Ok, something here is definitely off. You always want to use a cryptographically secure random number generator when you're doing, well, crypto. And the `random.getrandbits()` function is just python's basic RNG. Maybe there's something here we can work with.

After doing some digging, we discovered that the python `random.getrandbits()` function is actually a Pseudo-random Number Generator called a [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister). As a PRNG, the twister will create the numbers that do appear to be random on their own, but the sequence of numbers is deterministic - it always follows the same pattern if given the same inital input. If we can create a twister that is 'synced up' with the one on the server, we should be able to start generating the same numbers. This means that we can recreate the key and IV needed to decrypt the flag.

## The Solution

Luckily for us, it turns out that Mersenne Twister prediction is a pretty common CTF task, and as it so happens, someone has conveniently written a python library that can do the exact PRNG sync-up that we need. The package is literally called [Mersenne Twister Predictor](https://github.com/kmyk/mersenne-twister-predictor). All appropriate sacrifices to the CTF gods shall be made.

From the [docs for the library](https://github.com/kmyk/mersenne-twister-predictor), it looks like the predictor needs at least the last 624 numbers generated by the PRNG (and each number needs to be at least 32 bits long). So in total we'll need 624*32=19968 bits of previously generated data in order to sync our Merenne Twister with the one on the server:

```python
import random
from mt19937predictor import MT19937Predictor

predictor = MT19937Predictor()
for _ in range(624):
    x = random.getrandbits(32)
    predictor.setrandbits(x, 32)

assert random.getrandbits(32) == predictor.getrandbits(32)
```

Luckily for us, we are able to get random numbers from the system by using the `encrypt` option. Each time we sent a plaintext to be encrypted by the server, we got back a ciphertext, a key, and an IV, and we know from the source code that the key and IV are essentially just calls to the broken `getrandbytes()` function. We don't really care about the ciphertext, just about the IV and key. We can use those to set up our PRNG, and from there we can recreate the values we need to decrypt the flag.

Each time we call `encrypt`, we get 32\*8=256 bits from the key, and 16\*8=128 bits from the IV, for a total of 384 bits on each call. That means that we should be able to seed the PRNG with 52 calls to `encrypt`.

As a note, during the competition, we actually called `encrypt` 312 times - this was way overkill! We weren't sure if the PRNG needed a certain number of bits, or a certain number of discrete values, and while this would've been pretty easy to look up, it was also very late at night and my brain already hurt. So we went with the "better safe than sorry" option. In the end, 52 rounds is just fine!

### Solution Overview
1. Connect to the NC port
2. Call 'Encrypt' with dummy data 
3. Grab the key and the IV, and use them in `predictor.setrandbits()`
4. Repeat 52 times, in order to get the full 624 random bits needed to sync the PRNG
5. Call 'Get Encrypted Flag' which will:
    - generate two more 'random' numbers on the server side, a key and an IV
    - encrypt the flag under that key and IV
    - give us the flag as ciphertext
6. Generate the same two 'random' numbers on our side using our synced PRNG
7. Decrypt the flag using our generated 'random' numbers as the key and IV

## The Implementation
Here is the complete solution, in python:

```python
import binascii
from Crypto.Cipher import AES
from nclib import Netcat
from mt19937predictor import MT19937Predictor

# taken from the source code because I hate data conversion
def getrandbytes(predictor, n: int) -> bytes:
    return predictor.getrandbits(n * 8).to_bytes(n, "little")

# function that gets the necessary 624 random bits needed to properly align the MT19937 PRNG
def seed_predictor(predictor, nc):
    # each loop gets 2 numbers
    for i in range(52):
        # I need instant gratification
        print(i)

        # dump flavourtext
        for _ in range(5):
            nc.recvline()

        # select option 1 and send dummy data so that we'll receive a key and IV back
        nc.send(b"1\n")
        nc.recvline()
        nc.send(b"\n")
        nc.recvline()

        # get key (32 random bytes, 256 random bits)
        key = nc.recvline()[5:-1]                   # currently in raw ascii
        b_key = binascii.unhexlify(key)             # convert to bytestring
        int_key = int.from_bytes(b_key, "little")   # and finally to an int

        # get iv (16 random bytes, 128 random bits)
        iv = nc.recvline()[4:-1]                    # currently in raw ascii
        b_iv = binascii.unhexlify(iv)               # convert to bytestring
        int_iv = int.from_bytes(b_iv, "little")     # and finally to an int

        # # add these to the PRNG predictor
        predictor.setrandbits(int_key, 256)
        predictor.setrandbits(int_iv, 128)

def main():
    # create predictor to align PRNG
    p = MT19937Predictor()

    # connect to challenge
    nc = Netcat(("lazy-platform.challs.teamitaly.eu", 15004))

    # align the PRNG by getting keys and IVs from server
    seed_predictor(p, nc)

    # ask server for flag
    for _ in range(6):
        nc.recvline()
    nc.send(b"3\n")
    flag = nc.recvline()[14:-1]
    print("flag ciphertext: " + str(flag))
    b_flag = binascii.unhexlify(flag)

    # close connection to challenge
    nc.send(b"4\n")

    # generate a new key and IV using predicted RNG
    new_key = getrandbytes(p, 32)
    new_iv = getrandbytes(p, 16)

    # decrypt flag ciphertext
    plaintext = AES.new(new_key, AES.MODE_CBC, new_iv).decrypt(b_flag)
    print(plaintext)
    print(plaintext.decode('utf-8'))

if __name__ == "__main__":
    main()
```

And sure enough, when we run it, here's what we get:

```
flag ciphertext: b'1420a1abdedac4ce0f1ff9dfd71e0f2913dc15c8081f20d582b4476488c91bca9c676fac2a15ea58d8c2ac4dc283ed94'
b'flag{u53_s3cure_r4nd0m_numb3r_gen3r4t0rs}\x07\x07\x07\x07\x07\x07\x07'
flag{u53_s3cure_r4nd0m_numb3r_gen3r4t0rs}
```

Success!